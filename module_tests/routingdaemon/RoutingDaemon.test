%description:
Application module should send back the ConnectionSetupReq and InternalRuleSetForwarding to the router

%file: test.ned
import ned.DatarateChannel;
import modules.QRSA.RoutingDaemon.*;
import modules.QNode;

channel ClassicalChannel extends DatarateChannel
{
    double cost = default(1);
    double distance @unit(km) = default(20km);
    double speed_of_light_in_fiber @unit(km) = default(208189.206944km);
    delay = this.distance / speed_of_light_in_fiber * 1s;
    datarate = uniform(1kbps, 100kbps);
}

simple TestRoutingDaemon extends RoutingDaemon {
    parameters:
        double emission_success_probability;
    @class(TestRoutingDaemon);
    gates:
        inout port;
}
module MockQRSA {

    parameters:
        // Application needs the parent node's address
        int address;
        bool is_initiator = false;
        double emission_success_probability;
    gates:
        inout port;

    submodules:
        rd: TestRoutingDaemon {
            parameters:
                address = parent.address;
                // emission_success_probability = parent.emission_success_probability;
        }

    connections:
        port <--> rd.port;
}
module MockQNode {

    parameters:
        int address;
        string node_type;
        bool is_initiator;
        int mass;
        string included_in_topology = "yes";
        double emission_success_probability;
    gates:
        inout port[];

    submodules:
        qrsa: MockQRSA {
            parameters:
                address = parent.address;
                // emission_success_probability = parent.emission_success_probability;
        }

    connections:
        port[0] <--> qrsa.port;
}

network RoutingDaemonTestNet
{
    submodules:
        mockQNode1: MockQNode {
            address = 1;
            node_type = "EndNode";
            is_initiator = false;
            mass = 100;
        }
        mockQNode2: MockQNode {
            address = 2;
            node_type = "EndNode";
            is_initiator = false;
            mass = 100;
        }
    connections:
        mockQNode1.port++ <--> ClassicalChannel {  distance = 10km; } <--> mockQNode2.port++;
}

%inifile: routingdaemon.ini

[General]
network = RoutingDaemonTestNet
**.emission_success_probability = 1
RoutingDaemonTestNet.mockQNode1.qrsa.rd.emission_success_probability = 1;

%file: test_routingdaemon.cc
#include <omnetpp.h>
#include <messages/classical_messages.h>
#include <modules/QRSA/RoutingDaemon/RoutingDaemon.h>
#include <test_utils/TestUtils.h>
using namespace omnetpp;
using namespace quisp::messages;
namespace RoutingDaemon {
class Strategy : public quisp_test::TestComponentProviderStrategy {
    public:
    Strategy(cModule *_self): self(_self){}
    cModule* getQNode() override {return self->getParentModule(); }
    cModule *self;
};

class TestRoutingDaemon : public quisp::modules::RoutingDaemon {
 public:
  double emission_success_probability;
  TestRoutingDaemon() : RoutingDaemon() {
    this->provider.setStrategy(std::make_unique<Strategy>(this));
  }
  void finish() override {
    int other_node_addr = 3 - myAddress;
    if (qrtable[other_node_addr].pointer == nullptr) 
      printf("fail, routing table is not updated and the the pointer is nullptr\n");
    if (qrtable[other_node_addr].address != myAddress) 
      printf("node%d: fail, value is %d but the expected value is %d\n", myAddress, qrtable[other_node_addr].address, myAddress);
    else printf("you good\n");
  }
};
Define_Module(TestRoutingDaemon);
}; //namespace

%not-contains: test.out
fail